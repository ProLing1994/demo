#include "model.hpp"

extern "C" int rmai_novt_create_image(NOVT_IMAGE_S *image);
extern "C" void rmai_novt_destroyImg(NOVT_IMAGE_S *pstImg);

namespace ASR
{
    Model::Model()
    {
        novt_init();

        m_src_image = nullptr;
        m_asr_model = nullptr;
    }

    Model::Model(const Model_Options_S &model_options)
    {
        m_model_options = Model_Options_S(model_options);
        
        novt_init();

        m_src_image = nullptr;
        m_asr_model = nullptr;
    }

    Model::~Model()
    {
        if(m_src_image != nullptr)
        {
            rmai_novt_destroyImg(m_src_image);
            m_src_image = nullptr;
        }

        if(m_asr_model != nullptr)
        {
            delete ((novt_hwcnn::CNN *)(m_asr_model));
            m_asr_model = nullptr;
        }
    }

    void Model::novt_init()
    {
        novt_hwcnn::InitImageModule();
        memset((void *)&m_cnn_param, 0, sizeof(NOVT_CNN_PARAM_S));
    }

    void Model::novt_net_init(const char *model_path, void **model, const char *out_port_name)
    {
        //========initialize param========
        memset((void *)&m_cnn_param, 0, sizeof(NOVT_CNN_PARAM_S));

        m_cnn_param.pModelPath = const_cast<char *>(model_path); 
        m_cnn_param.output_layer_name.push_back(out_port_name);
        *model = (void *)(new novt_hwcnn::CNN(&m_cnn_param));
    }
    
    void Model::asr_init(const char *model_path, int feature_freq, int feature_time, const char *out_port_name)
    {
        // image 
        m_src_image = novt_hwcnn::CreateImage(NOVT_IMAGE_TYPE_U8C1, feature_freq, feature_time);
        // m_src_image = static_cast<NOVT_IMAGE_S *>(malloc(sizeof(NOVT_IMAGE_S)));
        // memset(m_src_image,0,sizeof(NOVT_IMAGE_S));
        // m_src_image->u32Width = feature_freq;
        // m_src_image->u32Height = feature_time;
        // m_src_image->enType = static_cast<NOVT_IMG_TYPE_E>(0);
        // rmai_novt_create_image(m_src_image);

        // model
        novt_net_init(model_path, &m_asr_model, out_port_name);
    }

    int Model::asr_forward(cv::Mat &input, cv::Mat *output)
    {   
        // std::cout << "\033[0;31m" << "[Information:] input_feature_freq: " << m_model_options.input_feature_freq \
        //             << ", input_feature_time: " << m_model_options.input_feature_time \  
        //             << ", output_feature_num: " << m_model_options.output_feature_num \  
        //             << ", output_feature_time: " << m_model_options.output_feature_time \  
        //             <<"\033[0;39m" << std::endl;

        // check
        if(input.rows !=  m_model_options.input_feature_time or input.cols !=  m_model_options.input_feature_freq)
        {
            printf("[ERROR:] %s, %d: Wrong Input Feature Shape.\n", __FUNCTION__, __LINE__);
            return -1;
        }
        if(output->rows !=  m_model_options.output_feature_time or output->cols !=  m_model_options.output_feature_num)
        {
            printf("[ERROR:] %s, %d: Wrong Output Shape.\n", __FUNCTION__, __LINE__);
            return -1;
        }

        // input
        input.copyTo(cv::Mat(cv::Size(m_src_image->u32Width, m_src_image->u32Height), 
                        CV_8UC1, (unsigned char*)(m_src_image->au32VirAddr[0]), m_src_image->au32Stride[0])); 

        // forward
        std::vector<NOVT_BLOB_S> layerout;
        int ret = ((novt_hwcnn::CNN *)(m_asr_model))->Run(m_src_image, layerout);
        if(layerout.size() == 0){
            printf("[ERROR:] %s, %d: ASR Net Forward failed.\n", __FUNCTION__, __LINE__);
            return ret;
        }
        // std::cout << "\033[0;31m" << "[Information:] layerout.size: " << layerout.size() \
        //             << ", [Information:] u32Chn: " << layerout[0].u32Chn \
        //             << ", u32Height: " << layerout[0].u32Height \ 
        //             << ", u32Width: " << layerout[0].u32Width \
        //             << ", u32Stride: " << layerout[0].u32Stride << std::endl;

        // test
        // cv::Mat temp_out = cv::Mat::zeros(37, 408, CV_32SC1);
        // output
        for(unsigned int i = 0; i < layerout.size(); i++)
        {
            for(unsigned int c = 0; c < layerout[i].u32Chn; c++)
            {
                for(unsigned int h = 0; h < layerout[i].u32Height; h++)
                {
                    for(unsigned int w = 0; w < layerout[i].u32Width; w++)
                    {
                        short* data = (short *)(layerout[i].u32VirAddr);
                        short tmp = data[c*layerout[i].u32Height*layerout[i].u32Width + h*layerout[i].u32Width + w];

                        output->at<float>(h, c) = (float)tmp / (float)(1 << layerout[i].out_shift);

                        // test
                        // temp_out.at<float>(h, c) = (float)tmp / (float)(1 << layerout[i].out_shift);
                        // std::cout << "i: " << c << ", j: " << h <<  ", k: " << w << ", value: "<< (float)tmp / (float)(1 << layerout[i].out_shift) << std::endl;
                    }
                }
            }
            
            // test
            // float *p_data = (float *)temp_out.data;
            // for (int i = 0; i < 37; i++)
            // {
            //     float sum = 0.0;
            //     for (int j = 0; j < 408; j++)
            //     {
            //         sum += (float)*(p_data + j + i * temp_out.cols);
            //     }
            //     std::cout << "i: " << i << ", sum: " << sum << ", data[0]: " << (float)*(p_data + 0 + i * temp_out.cols) << std::endl;
            // }
        }
        return ret;
    }

} // namespace ASR